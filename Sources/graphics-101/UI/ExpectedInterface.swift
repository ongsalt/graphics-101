import Observation

// protocol View {}
// private struct Div: View {}
// private struct Text: View {
//     let text: String
//     init(_ text: String) {
//         self.text = text
//     }
// }

// class MyWidget {
//     var count = 0
//     var body: some View {
//         Text("yo mum \(count)")
//         Button("+") { [unowned self] in
//             count += 1
//         }
//     }
// }

// // make reactive props explicit?

// class OtherWidget {
//     // write
//     init(text: String) {
//         // non reactive
//         self.text = text
//         // reactive
//         #link(self.text, to: text)

//         // what if self.text is not reactive but text is
//     }

//     // autogenerated?, for every fucking prop
//     init(text: some Source<String>) {

//         // ...
//     }
// }

/*
We dont have `untrack { }` tho
TODO: check OpenObservation

*/

private func Text(_ string: String) -> some UI {
    UIImpl()
}

// -----------------------------------------------------------

// // Function component?
// // its easier to do props, explicit props reactivity
// // autogenerate non reactive overload?
// @Component: attached macro can modify the code, we can just declare another one in our namespace
// func `_-SomePrefixðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥::Counter`(text: ReadOnlySignal<String>, count: Signal<Int>) {}
// func Counter(text: String, count: inout Int) {

//     let count2 = #signal(0)

//     // let count = Signal(0)

//     // i wont know if the fn is our fn or not tho
//     // or make this scope a result builder
//     // we should allow class based component with no other binding too
//     return #ui {
//         Text("count: \(count)")
//         // transform into, only if expression is not Source,
//         // how tf do i get type info
//         Text(Computed { "count: \(count)" })
//         // if its
//     }
// }

// ------------------------------------------------------------------------
// Explicit state

// this is just for typing, this wont run it will be codegen
@resultBuilder
private private struct OurViewBuilder {
    typealias Expression = UI

    /// The type of a partial result, which will be carried through all of the
    /// build functions.
    typealias Component = [UI]

    /// The type of the final returned result, which defaults to Component if
    /// buildFinalResult() is not provided.
    typealias Result = UI

    static func buildBlock(_ components: Component...) {}

    static func buildExpression(_ expression: Expression) -> Component {
        [expression]
    }
}

protocol UI {

}

private struct UIImpl: UI {}
private struct TextUIImpl: UI {

}

@freestanding(expression)
macro ui(
    // Apply @ViewBuilder here
    @OurViewBuilder _ content: () -> Void
) -> UIImpl = #externalMacro(module: "MyPlugin", type: "MyContainerMacro")


// no auto derived
private func Counter(text: String, reactiveText: String) -> some UI {
    Counter(text: text, reactiveText: Signal(reactiveText))
}


// @Component
// func Counter(text: String, reactiveText: Signal<String>, children: () -> some UI) -> some UI {}
private func Counter(text: String, reactiveText: Signal<String>) -> some UI {
    let xContext = XContext.current
    let count = Signal(0)

    return #ui {  // just lie to the compiler that this is type UI
        Text("count: \(count)")
        Counter(text: "count", reactiveText: "count: \(count.value)")
        // children()
        // binding can be just passing a mutable state
        // or #bind(value) for non signal stuff
    }
}

// then some system state is just
@Observable
private class SystemContext: Context {
    private(set) var isDark: Bool
// context has current {get, set} which is actually a push ops
// auto pop when leave component scope
// component should just get an unowed ref
}

private func `code generated by #ui`() {
    // very minimal codegen????

    // save it
    let runtime = OurUIRuntime.current

    runtime.if { 
        // make this a derived
        evaluate condition
    } then: {

    } otherwise: {

    }

    // for each is just another component
    // no, WE ARE COMPILER, WE CAN DO ANYTHING
    // cant do keying fn, so pls implement Identifiable

    runtime.startComponentScope {
        // how do we know which is which
        // Text("static", Computed { "count: \(count)" })

        // solid just cheat it by detecting a fn call expression ()
        // can we then detect .value lmao
        // and just add a warning 

        Text("static", derivedCount)
    }
}

// wait does this mean 2^n overload, fuck
// no: just fucking @autoclosure everything marked with Binding<T> and ReadOnlyBinding<T>
// - define binding by Binding<T> which is just .value {get, set} with a getter, setter

// in summary, function component create a lot of closure and heap promotion
// but easier to write
// well, if leptos can do it, why cant we
// TODO: benchmark this???

// -----------------------------------------------------------

// // or Jetpack compose like api
// // there are 2 way to do this: composer or whatever tf RippleTS is doing

// // i kinda like that when you declare a reactive state they will generate another variable `@name`
// // the original is State<T> while `@name` look like `T`
// // swiftui also do this but in reverse
